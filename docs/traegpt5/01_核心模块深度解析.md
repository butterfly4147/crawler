# 核心模块深度解析（Master、Engine、Spider）

本文件从调度与执行两大维度深入解析核心模块，帮助你在代码层面构建清晰的心智模型，并提供与游戏服务器架构的类比以加速理解。

## Master：选举、资源管理与任务分配

代码位置：`master/master.go`、`master/option.go`

### 核心职责
- Leader 选举：保证只有一个 Master 负责分配任务。
- 资源管理：维护任务资源（添加/删除/更新）。
- 任务分配：根据 Worker 状态与策略分配资源。

### 关键数据结构（示意）
```go
type Master struct {
    ID        string
    workNodes map[string]*NodeSpec      // Worker 节点集合
    resources map[string]*ResourceSpec  // 资源（任务）集合
    // ... etcd、micro、日志等依赖
}

type NodeSpec struct {
    ID      string
    Addr    string
    Weight  int
    // 心跳、负载等指标
}

type ResourceSpec struct {
    Name   string
    Status string
    // 任务配置、优先级、并发等
}
```

### 关键方法（语义）
- `Campaign()`：参与 Leader 选举，监听选举结果。
- `BecomeLeader()`：当选 Leader 后初始化分配循环、监听资源变化。
- `AddResource()`：新增抓取资源，触发分配。
- `Assign()`：负载均衡分配算法，将资源派发到合适的 Worker。
- `DeleteResource()`：删除资源，通知 Worker 停止并清理。

### 实现要点
- 基于 `etcd concurrency.Election` 的选举，保障唯一调度者。
- 分配策略可扩展：最小负载、权重、轮询、亲和性等。
- 故障转移：Leader 宕机后通过选举产生新 Leader 并继续任务。

### 游戏服务器类比
- Master ≈ 主服/匹配服：负责将玩家（任务）分配到房间（Worker）。
- 选举 ≈ 主从切换：保持唯一调度者，避免双写与冲突。

## Engine：调度、并发与去重重试

代码位置：`engine/schedule.go`、`engine/option.go`

### 角色概述
- 作为 Worker 的抓取引擎核心：请求队列、优先级、并发控制、去重与失败重试。

### 关键结构（摘录）
```go
type Schedule struct {
    requestCh   chan *spider.Request   // 新请求入口
    workerCh    chan *spider.Request   // 工作者通道
    priReqQueue []*spider.Request      // 优先级队列
    reqQueue    []*spider.Request      // 普通队列
}

type Crawler struct {
    out      chan spider.ParseResult
    Visited  map[string]bool                 // 去重
    failures map[string]*spider.Request      // 失败重试
}
```

### 请求生命周期
1. `Task.Root()` 返回初始 `Request`。
2. `Schedule.Push()` 入队，按 `Priority` 进入相应队列。
3. `CreateWork()` 以受控并发拉取请求并执行抓取。
4. 解析结果通过 `out` 输出，失败进入 `failures`，按策略重试。

### 重要方法与机制
- `AddJsReqs/AddJsReq`：通过 `otto` JS 运行时动态生成请求，便于复杂站点规则定义。
- 去重：`Crawler.Visited` + 唯一 ID（URL+Method+Rule 等）避免重复抓取。
- 重试：对失败请求记录并按策略（退避/次数上限）重试。
- 并发控制：基于 goroutine 与通道限速，结合 `limiter` 细粒度控制。

### 游戏服务器类比
- 调度器 ≈ 任务派发器：优先级、队列、并发控制同理。
- 去重 ≈ 幂等/状态管理：避免重复执行或状态冲突。

## Spider：任务、规则树与解析上下文

代码位置：`spider/task.go`、`spider/parse.go`、`spider/request.go`

### 关键结构
```go
type Task struct {
    Visited map[string]bool
    Rule    RuleTree
    Options
}

type RuleTree struct {
    Root  func() ([]*Request, error)
    Trunk map[string]*Rule
}

type Rule struct {
    ItemFields []string
    ParseFunc  func(*Context) (ParseResult, error)
}

type Request struct {
    URL      string
    Method   string
    Depth    int64
    Priority int64
    RuleName string
}
```

### 解析流程
1. `Root()` 给出入口请求集。
2. 引擎按 `RuleName` 找到 `Trunk` 中的解析规则。
3. `Context` 提供取数、输出、正则/JS 解析等能力。
4. `ParseFunc` 生成新请求或输出数据，形成爬取树。

### 重要能力
- `Context.OutputJS/ParseJSReg`：支持动态脚本与复杂匹配提取。
- `Request.Unique()`：组合字段生成唯一 ID，支撑去重。

### 游戏服务器类比
- 规则树 ≈ 玩法/脚本树：每个规则节点代表一个处理阶段，可拓展与复用。

## 模块协作与数据链路
1. Master 维护资源并分配给 Worker。
2. Worker 引擎监听资源变更，驱动 Spider 执行规则树。
3. 解析结果通过 Storage 写入 MySQL。
4. 观测与日志贯穿全链路，支持故障排查与性能优化。

## 扩展与演进建议
- 调度策略：加入权重/亲和/地理位置信息优化分配。
- 去重提升：引入布隆过滤器或分布式去重（Redis/etcd 协调）。
- 存储扩展：实现 `storage.Storage` 接口的 Redis/ES/S3 等存储插件。
- 解析增强：浏览器渲染抓取、反爬策略（UA/代理/速率/随机化）。

建议下一步阅读《02_学习路线图.md》，按阶段完成理论—代码—实践的闭环。